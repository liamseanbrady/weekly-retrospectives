# 27/09/2015 to 03/10/2015

- Read through Katrina Owen's Exercism code from the first commit onwards. I reviewed the code from the initial commit and from there on I compared diffs of each commit to see how the code was changing and trying to understand how an experienced developer thinks. Here are some technical things I learned:
  - You can test that something reads accurately from a file in a particular location by allowing the injection of a path into your method, and then working with that path. For example, if you're reading from a config file, you could make the default path the root of the directory or `~/.app_name`, but in tests you can pass in `./tests/fixtures` and then you only have to rely on putting a `config.yml` file in `./tests/fixtures` yourself. The general code I'm talking about is [here](https://github.com/exercism/exercism.io/blob/90f07ec1f2d4c874d187995dff7b055e20d0f046/test/exercism/curriculum_test.rb#L15).
- Kept getting an inconsistent error in tests (i.e., the test would sometimes fail and sometimes pass). What I did was to use inline ruby in the terminal to run the test multiple times to start homing in on what the problem was. `ruby -e "15.times { system('rspec') }"`  
- Make sure when using workers with Heroku that you have actually enabled the worker on the herkou dashboard.
- Another problem I had was that in my staging app the css file was not being loaded. This problem came from the fact that I forgot to add `:staging` to `group :production do` which included the `rails_12factor` gem which deals with the asset pipeline on Heroku. You can read more about it [here](https://github.com/heroku/rails_12factor)
- Always use `Hash#fetch` instead of `Hash#[]`. It's much safer.
- In Rails, should I be committing my db/seeds.rb to GitHub? This could reveal a lot about the structure of your models.
- Saw `File.readlines('path').rewind` being used in Carrierwave's source (in the initial commit), and looked it up. `rewind` could be a useful method to be aware of in the future.
- I did [this](http://users.evtek.fi/~jaanah/IntroC/DBeech/3gl_flow.htm) tutorial on using flowcharts to work through the logic of solving a problem. It really helped me organize my thoughts. It felt good to get out of the 'I am a programmer so I must work with code always' mindset. I wouldn't mind working like this for all logical problems in the future. It helped me remove the possibility of getting caught up in code, and made me feel like I would definitely solve the problem. Sometimes when trying to problem solve and write code at the same time, it can be difficult to separate the two. This way, it forces me to do so - it actually **feels** like I'm solving a problem.
- Did a problem from Exercism. It's the second one I've done and it's highlighted my need to work on solving logic problems. I discovered that I like to jump into a problem before fully understanding it, which causes problems down the line. I'm going to work on a least one problem every week and my focus at the moment is asking as many problems as I can about the problem before trying to solve it. I want to know and understand every nook and cranny of it before sitting down to code. I used a flowchart on the last problem, which did help clarify the problem more so than just sitting down and writing some pseudo-code.
- `git tag -a tag_name -m 'tag message'` can be used to tag a particular commit as the start of something like a new official version of the code. You can tag specic commits after the fact by passing in the commit's SHA `git tag -a v1.2 9fceb02`.
- `git log --pretty=online` shows commits as one line. Very handy when you don't need all of the extra metadata.
- Writing Effective Use Cases by Alastair Cockburn seems to be a super useful book to read. Doing TDD would probably be a lot smoother for me if I had use cases.
- Always use setteers and getters for setting and getting ivars inside a class. This allows you to memoize the value of that ivar, and also allows you to lazy initialize ivars as opposed to setting it in the initializer of the object it's part of. It also means that if you decide to change to underlying structure of the code, the names can remain the same and you can just change the one method, as opposed to changing the value of the ivar everywhere. Basically, **it allows for a shim to be placed between messages to ivars so that the underlying logic can be changed easily**.
- **TDD tip!**: Any time you are performing a state changing operation, make sure that you're also asserting what the expected state is before performing that operation as well.
- **TDD tip!**: There are two types of verifications you can make in tests: **state-based**, and **interaction-based**. Basically, the first verifies that something in the state of the object under test has changed; the second verifies that the object under test made a predicted and successful interaction with a collaborating object (for example, sending the correct message with the correct paramaters). Interaction-based verification lets us **completely defer** implementing the message sent to a later time, and we don't have to rely on any real implementation of that message at that point. State-based verification requires us to create an implementation of some sort (this doesn't need to be the 'real' class, but could be a mock object). It is useful to be able to test things in a state-based way, but often it's prefereable to use interaction-based verifications because it makes the object more isolated, and it also makes the tests more isolated. If you break the implementation of the mock object, then you have to track down where exactly it happened, whereas with an interaction-based test, there's really only a single point of failure. **The balance between interaction-based and state-based tests is basically the balance between code coverage and defect isolation** - the more code the gets exectuted in a particular test (state-based), the more overall coverage that we have, but we don't have very good defect isolation; when something breaks, we don't know exactly what broke, how, why, or how to fix it.
- **Tests are used to serve three purposes: behaviour verification, defect isolation, and design feedback**.
- `exit-program` to get out of `pry` whenever you want.
- In RSpec, you can mark fully-written tests as pending (and essentially **skip** them) by preceding the `it` with an '**x**', it reads `xit 'does something'`. You can also do `before { pending }` to skip a whole block of tests and mark them as pending.
- In RSpec, if you do `rspec -f d spec/some_spec.rb`, this will show you the structure of the tests in a spec/use case format. I find this to be **super helpful**, when thinking about what the tests are actually doing and how they fit into building the current feature!
- `arr.join.scan(/.{1,3}/)` matches between 1 and 3 of any character and returns an array of the results. Basically it splits a string into segments of size 3. 




## Things I watched/listened to

- [Ruby Rogues episode](https://devchat.tv/ruby-rogues/023-rr-book-club-smalltalk-best-practice-patterns-with-kent-beck) with Kent Beck talking about Smalltalk Best Practice Patterns. I learned about:
  1. Composed Method pattern. I found a good definition of this pattern: "Divide your program into methods that perform one identifiable task. Keep all of the operations in a method at the same level of abstraction. This will naturally result in programs with many small methods, each a few lines long.". It seems like Composed Method is Extract Method performed multiple times until the contents of each method is at the same level of abstraction internally.
  2. It would be very beneficial to learn Smalltalk someday.
- Gregory Brown 'Programming Beyond Practices' newsletter on [Sweeping complexity under the rug (Challenges in architectural modularity, Part II)](http://tinyletter.com/programming-beyond-practices/letters/sweeping-complexity-under-the-rug-challenges-in-architectural-modularity-part-ii) - this talked about the thought process one might go through when developing an architecture a web app that works with messy/legacy data and legacy technologies (before HTTP web services existed). This was fascinating, and the most obvious lesson I took away from it was to always try to abstract away things that you don't own with a wrapper or proxy. Once you've taken care of safely wrapping the system with a stable and understandable API, then you're free to interact with it as you would any other web service. Sometimes it's okay to sweep comlexity under the rug by separating easy to change/maintain code from unreliable code and data in the name of dealing with the situation with the limitations given to you. This article also lead me to reading the [Sweeping it Under the Rug section of Big Ball of Mud](http://www.laputan.org/mud/mud.html#SweepingItUnderTheRug), which talks about how isolating the big mess which was previously scattered throughout the room into a neat, but giant, mess in the middle of the floor is sometimes the best that can be done (at least as a first step). This allows you to at least interact with a horrible, but functioning, blob of code like it were a lovely, fresh collection of code with an understandable API. Another moral I took away from this was not to be precious about my code - even if I think it's the best code ever now, someday it will be awful and horribly out-of-date. You can skip a whole bunch of pain by disconnecting yourself from your code and be willing to throw it all away at the drop of a hat.
- I found a fantastic collection of topics and lessons for developers from Turing School [here](https://github.com/turingschool/curriculum/tree/master/source/topics).
- Watched Dave Thomas's talk on [Ruby Object Model](https://www.youtube.com/watch?v=X2sgQ38UDVY&index=64&list=WL). I learned the following things:
  1. **Simula** was the first language to really cater for the concept of object-orientation. Alan Kay, with Smalltalk, took the ideas of Simula and essentially built Smalltalk around them. Alan Kay also invented the term 'object-oriented'.
  2. Object-orientation is **not** programming with classes, rather it's about objects sending messages.
  3. I feel like I understand Ruby a lot better at a fundamental level now and can read `class MyClass; end` to be assigning a `Class` object to the constant `MyClass` in the same way I would assign a `String` object to the variable `my_string`. The only difference is that it is a Constant as opposed to a variable.
  4. This also really helped me understand the importance of knowing what `self` is at all times, and how this really simplifies metaprogramming.
  5. A simple way of visualizing a method call is: call method on receiver; set self to receiver; look up method name in self's method table; invoke method; restore original value of self.
  6. When you define a method on a single instance of a class, Ruby automatically creates a singleton class and the parent pointer for the singleton class now points to the original superclass of that instance in order to keep the method lookup chain intact. We've essentially just injected an anonymous class into the method lookup chain. There's only one singleton class per object.
  7. In Ruby, the name of a class is just a constant that references a Class object. So, what Ruby does when I create a new Class object is that it creates a new instance of Class for me and then assigns that instance of Class to a constant with the name that I place after `class` in my class definition.
  8. When you define a 'class method' in Ruby, all you're doing is defining a singleton method on that instance of Class. It's helpful to think of it in two steps. The first step is that doing `class MyClass` already creates an instance of that class and sets `self` to that instance, then `def self.my_class_method; end` will define a singleton method on that instance of Class in the same way that doing `my_class = MyClass.new; def my_class.my_singleton_method; end` will create a singleton method on an instance of `MyClass`. There's no difference between them, expect they are in different singleton classes.
  9. Remember that instance variables get looked up in self, and methods get looked up in self's class. A simple way to think about this is that, at a basic level, an instance of a class can have unique state with instance variables, but the content of an instance's methods can't change (unless you inject a singleton class).
  10. When you define singleton methods with `class << cat_instance; def meow_uniquely; end; end` all you're doing with `class << cat_instance` is saying 'open up the singleton class of this object and make self that singleton class then add these methods in that singleton class'.
  11. For class methods, doing `class MyClass; class << self; def my_class_method; end; end; end;` is exactly the same as `class MyClass; def self.my_class_method; end; end;`. All that's happening is it's saying 'open up the singleton class for self (MyClass) and add these methods there'.
- I'm making an effort to learn a little more about Git every day. I know enough at this stage to do all of the basics, submit pull requests, keep forks up to date, and generally do most of what a junior developer would be expected to do in Git. I want to go further and avoid messing things up in Git as a junior developer, so my topic for this week is: [Don't Fear the Rebase: Git Garbage Collection and You](http://blog.carbonfive.com/2015/07/01/dont-fear-the-rebase-git-garbage-collection-and-you/). From reading this post, I learned:
  - `git reflog` basically shows a timeline of all of your actions in the repo.
  - `git reflog` can be valuable for find that SHA of a commit that doesn't appear in `git log`, for example if you amend a commit, then want to retrieve the original commit before amending it, the only way to do this is to access the commit via the SHA which is only visible in `git reflog`.
  - With `git reflog`, no action is ever really written in stone. There's always a way to `git reset --hard 5b5jd84` and get back to a previous point, like nothing ever happened.
  - As a mild detour, I checked out [Rewriting History in Git](https://www.atlassian.com/git/tutorials/rewriting-history) to find out more about `git rebase`. Git commands learned/refreshed:
    1. `git commit --amend`. Basically allows you to either combine staged changes with the previous commit instead of committing them as a new commit, or it allows you to edit the commit message. It's worth bearing in mind that even though the name of this command is `amend`, it actually creates a brand new commit and replaces the previous commit. If you just want to add staged changes to the most recent commit, but not alter the commit message, you can do `git commit --amend --no-edit`.
    2. Rule: **never amend or reset commits which have been pushed to a public repo**.
    3. `git rebase`. Rebasing is the process of moving a branch to a new base commit. A common usage is when you've started a feature branch, but then whilst you're working on that feature, 2 or 3 commits have been made to master. In this scenario, `git rebase` can be used to change the 'base' of that feature branch to be the tip of master currently. Then you can safely merge with master.
    4. `git rebase -i` allows you to change the project history **in your private branch** to whatever you want it to be. You can squash commits, for example, and tidy up all of the commits related to that branch to keep the project history in general nice and tidy.
